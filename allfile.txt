=== File: /home/rvph/restaurant-manager/frontend/next.config.js ===

/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
};

module.exports = nextConfig;

=== End of /home/rvph/restaurant-manager/frontend/next.config.js ===


=== File: /home/rvph/restaurant-manager/frontend/.env.example ===

NEXT_PUBLIC_API_URL=http://localhost:5000
=== End of /home/rvph/restaurant-manager/frontend/.env.example ===


=== File: /home/rvph/restaurant-manager/frontend/.npmrc ===

legacy-peer-deps=true
=== End of /home/rvph/restaurant-manager/frontend/.npmrc ===


=== File: /home/rvph/restaurant-manager/frontend/postcss.config.js ===

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

=== End of /home/rvph/restaurant-manager/frontend/postcss.config.js ===


=== File: /home/rvph/restaurant-manager/frontend/src/app/page.tsx ===

export default function Home() {
  return (
    <main className="min-h-screen p-8">
      <h1 className="text-3xl font-bold">Restaurant Management System</h1>
      <p className="mt-4">Welcome to the restaurant management system</p>
    </main>
  );
}

=== End of /home/rvph/restaurant-manager/frontend/src/app/page.tsx ===


=== File: /home/rvph/restaurant-manager/frontend/src/app/globals.css ===

@tailwind base;
@tailwind components;
@tailwind utilities;
=== End of /home/rvph/restaurant-manager/frontend/src/app/globals.css ===


=== File: /home/rvph/restaurant-manager/frontend/src/app/layout.tsx ===

import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: 'Restaurant Management',
  description: 'Restaurant Management System',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}

=== End of /home/rvph/restaurant-manager/frontend/src/app/layout.tsx ===


=== File: /home/rvph/restaurant-manager/frontend/tailwind.config.ts ===

import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;

=== End of /home/rvph/restaurant-manager/frontend/tailwind.config.ts ===


=== File: /home/rvph/restaurant-manager/backend/.env.example ===

NODE_ENV=development
PORT=5000
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/restaurant_db
REDIS_URL=redis://redis:6379
JWT_SECRET=your-super-secret-key-change-this
JWT_EXPIRES_IN=7d
CORS_ORIGIN=http://localhost:3000
SESSION_SECRET=your-session-secret-key-change-this
SENTRY_DSN=your-sentry-dsn
=== End of /home/rvph/restaurant-manager/backend/.env.example ===


=== File: /home/rvph/restaurant-manager/backend/.env ===

NODE_ENV=development
PORT=5000
DATABASE_URL=postgresql://postgres:postgres@postgres:5432/restaurant_db
REDIS_URL=redis://redis:6379
JWT_SECRET=your-super-secret-key-change-this
JWT_EXPIRES_IN=7d
CORS_ORIGIN=http://localhost:3000
SESSION_SECRET=your-session-secret-key-change-this
SENTRY_DSN=your-sentry-dsn
=== End of /home/rvph/restaurant-manager/backend/.env ===


=== File: /home/rvph/restaurant-manager/backend/wait-for-it.sh ===

#!/bin/sh
set -e

until PGPASSWORD=postgres psql -h "postgres" -U "postgres" -c '\q'; do
  >&2 echo "Postgres is unavailable - sleeping"
  sleep 1
done

>&2 echo "Postgres is up - executing command"
exec "$@"
=== End of /home/rvph/restaurant-manager/backend/wait-for-it.sh ===


=== File: /home/rvph/restaurant-manager/backend/src/routes/index.routes.ts ===

import { Router } from 'express';
import { inventoryRoutes } from './inventory.routes';

const router = Router();

router.use('/inventory', inventoryRoutes);

export { router };

=== End of /home/rvph/restaurant-manager/backend/src/routes/index.routes.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/routes/inventory.routes.ts ===

// src/routes/inventory.routes.ts

import { Router } from 'express';
import { InventoryController } from '../controllers/inventory.controller';

const router = Router();
const inventoryController = new InventoryController();

// Ingredient routes
router.post('/ingredients', inventoryController.createIngredient);
router.get('/ingredients', inventoryController.getIngredients);
router.get('/ingredients/:id', inventoryController.getIngredient);
router.patch('/ingredients/:id', inventoryController.updateIngredient);
router.delete('/ingredients/:id', inventoryController.deleteIngredient);

// Product routes
router.post('/products', inventoryController.createProduct);
router.get('/products', inventoryController.getProducts);
router.get('/products/:id', inventoryController.getProduct);
router.patch('/products/:id', inventoryController.updateProduct);
router.delete('/products/:id', inventoryController.deleteProduct);

// Category routes
router.post('/categories', inventoryController.createCategory);
router.get('/categories', inventoryController.getCategories);

export { router as inventoryRoutes };
=== End of /home/rvph/restaurant-manager/backend/src/routes/inventory.routes.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/services/customer.service.ts ===

import { prisma } from '../prisma/client';
import { Customer, Employee } from '@prisma/client';
import { logger } from '../lib/logging/logger';

export class CustomerService {
  public async findUser(params: {
    id?: string;
    email?: string;
    phone?: string;
  }): Promise<Customer | Employee | null> {
    try {
      const { id, email, phone } = params;

      if (!id && !email && !phone) {
        throw new Error('At least one search parameter is required');
      }

      const whereClause: any = {
        OR: [],
      };

      if (id) {
        whereClause.OR.push({ id });
      }
      if (email) {
        whereClause.OR.push({ email });
      }
      if (phone) {
        whereClause.OR.push({ phone });
      }

      return await prisma.employee.findFirst({
        where: whereClause,
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          status: true,
          department: true,
          roles: {
            select: {
              role: {
                select: {
                  name: true,
                },
              },
            },
          },
          lastLogin: true,
          createdAt: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      logger.error('Error finding user:', error);
      throw error;
    }
  }

  async userExists(params: { id?: string; email?: string; phone?: string }): Promise<boolean> {
    try {
      const user = await this.findUser(params);
      return !!user;
    } catch (error) {
      logger.error('Error checking user existence:', error);
      throw error;
    }
  }
}

=== End of /home/rvph/restaurant-manager/backend/src/services/customer.service.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/services/inventory.service.ts ===

import { prisma } from '../prisma/client';
import { Ingredient, MeasurementUnit, Product, Category } from '@prisma/client';
import { auditLog, logger } from '../lib/logging/logger';

export class InventoryService {
  async createIngredient(data: {
    user: string;
    name: string;
    description?: string | null;
    stock: number;
    unit: MeasurementUnit;
    reorderPoint: number;
    reorderAmount: number;
    cost: number;
    isExtra: boolean;
    extraPrice?: number | null;
    supplierId: string;
  }): Promise<Ingredient> {
    try {
      const ingredient = await prisma.ingredient.create({
        data: {
          name: data.name,
          description: data.description,
          stock: data.stock,
          unit: data.unit,
          reorderPoint: data.reorderPoint,
          reorderAmount: data.reorderAmount,
          cost: data.cost,
          isExtra: data.isExtra,
          extraPrice: data.extraPrice,
          supplierId: data.supplierId,
        },
      });

      await auditLog(
        'CREATE_INGREDIENT',
        {
          ingredientId: ingredient.id,
          ingredientName: ingredient.name,
          action: 'Created new ingredient',
        },
        data.user
      );

      return ingredient;
    } catch (error) {
      logger.error(`Error creating ingredient: ${error}`);
      throw error;
    }
  }

  async updateIngredient(data: {
    user: string;
    id: string;
    name?: string;
    description?: string | null;
    stock?: number;
    unit?: MeasurementUnit;
    reorderPoint?: number;
    reorderAmount?: number;
    cost?: number;
    isExtra?: boolean;
    extraPrice?: number | null;
    supplierId?: string;
  }): Promise<Ingredient> {
    try {
      const ingredient = await prisma.ingredient.update({
        where: { id: data.id },
        data: {
          name: data.name,
          description: data.description,
          stock: data.stock,
          unit: data.unit,
          reorderPoint: data.reorderPoint,
          reorderAmount: data.reorderAmount,
          cost: data.cost,
          isExtra: data.isExtra,
          extraPrice: data.extraPrice,
          supplierId: data.supplierId,
        },
      });

      await auditLog(
        'UPDATE_INGREDIENT',
        {
          ingredientId: ingredient.id,
          ingredientName: ingredient.name,
          action: 'Updated ingredient',
        },
        data.user
      );

      return ingredient;
    } catch (error) {
      logger.error(`Error updating ingredient: ${error}`);
      throw error;
    }
  }

  async deleteIngredient(data: { user: string; id: string }): Promise<Ingredient> {
    try {
      const ingredient = await prisma.ingredient.delete({
        where: { id: data.id },
      });

      await auditLog(
        'DELETE_INGREDIENT',
        {
          ingredientId: ingredient.id,
          ingredientName: ingredient.name,
          action: 'Deleted ingredient',
        },
        data.user
      );

      return ingredient;
    } catch (error) {
      logger.error(`Error deleting ingredient: ${error}`);
      throw error;
    }
  }

  async getIngredients(): Promise<Ingredient[]> {
    try {
      return await prisma.ingredient.findMany({
        include: {
          supplier: true,
          stockLogs: {
            take: 5,
            orderBy: {
              createdAt: 'desc',
            },
          },
        },
      });
    } catch (error) {
      logger.error(`Error getting ingredients: ${error}`);
      throw error;
    }
  }

  async getIngredient(id: string): Promise<Ingredient> {
    try {
      return await prisma.ingredient.findUnique({
        where: { id },
      });
    } catch (error) {
      logger.error(`Error getting ingredient: ${error}`);
      throw error;
    }
  }

  async getIngredientByName(name: string): Promise<Ingredient> {
    try {
      return await prisma.ingredient.findFirst({
        where: { name },
      });
    } catch (error) {
      logger.error(`Error getting ingredient by name: ${error}`);
      throw error;
    }
  }

  async createProduct(data: {
    user: string;
    name: string;
    description?: string | null;
    categoryId: string;
    image?: string | null;
    preparationTime: number;
    allergens?: string[] | [];
    nutritionalInfo?: string | {};
    isAvailable: boolean;
    price: number;
    ingredients: {
      ingredientId: string;
      quantity: number;
    }[];
  }): Promise<Product> {
    try {
      const product = await prisma.product.create({
        data: {
          name: data.name,
          description: data.description,
          categoryId: data.categoryId,
          image: data.image,
          preparationTime: data.preparationTime,
          allergens: data.allergens,
          nutritionalInfo: data.nutritionalInfo,
          price: data.price,
          isAvailable: data.isAvailable,
          ingredients: {
            create: data.ingredients.map((ingredient) => ({
              ingredientId: ingredient.ingredientId,
              quantity: ingredient.quantity,
              unit: 'PORTIONS',
              isOptional: false,
            })),
          },
        },
        include: {
          ingredients: {
            include: {
              ingredient: true,
            },
          },
          category: true,
        },
      });

      await auditLog(
        'CREATE_PRODUCT',
        {
          productId: product.id,
          productName: product.name,
          categoryId: product.categoryId,
          ingredientCount: data.ingredients.length,
          action: 'Created new product',
        },
        data.user
      );

      return product;
    } catch (error) {
      logger.error(`Error creating product: ${error}`);
      throw error;
    }
  }

  async updateProduct(data: {
    user: string;
    id: string;
    name?: string;
    description?: string | null;
    categoryId?: string;
    image?: string | null;
    preparationTime?: number;
    allergens?: string[] | null;
    nutritionalInfo?: Record<string, any> | null;
    isAvailable?: boolean;
    price?: number;
    ingredients?: {
      ingredientId: string;
      quantity: number;
    }[];
  }): Promise<Product> {
    try {
      // First check if product exists
      const existingProduct = await prisma.product.findUnique({
        where: { id: data.id },
        include: { ingredients: true },
      });

      if (!existingProduct) {
        throw new Error('Product not found');
      }

      // Prepare update data excluding undefined values
      const updateData: any = {};

      if (data.name !== undefined) updateData.name = data.name;
      if (data.description !== undefined) updateData.description = data.description;
      if (data.categoryId !== undefined) updateData.categoryId = data.categoryId;
      if (data.image !== undefined) updateData.image = data.image;
      if (data.preparationTime !== undefined) updateData.preparationTime = data.preparationTime;
      if (data.allergens !== undefined) updateData.allergens = data.allergens;
      if (data.nutritionalInfo !== undefined) updateData.nutritionalInfo = data.nutritionalInfo;
      if (data.price !== undefined) updateData.price = data.price;
      if (data.isAvailable !== undefined) updateData.isAvailable = data.isAvailable;

      // Only update ingredients if provided
      if (data.ingredients) {
        updateData.ingredients = {
          deleteMany: {}, // Delete existing ingredients
          create: data.ingredients.map((ingredient) => ({
            ingredientId: ingredient.ingredientId,
            quantity: ingredient.quantity,
            unit: 'PORTIONS',
            isOptional: false,
          })),
        };
      }

      const product = await prisma.product.update({
        where: { id: data.id },
        data: updateData,
        include: {
          ingredients: {
            include: {
              ingredient: true,
            },
          },
          category: true,
        },
      });

      await auditLog(
        'UPDATE_PRODUCT',
        {
          productId: product.id,
          productName: product.name,
          categoryId: product.categoryId,
          ingredientCount: data.ingredients?.length ?? existingProduct.ingredients.length,
          changes: Object.keys(updateData).join(', '),
          action: 'Updated product',
        },
        data.user
      );

      return product;
    } catch (error) {
      logger.error(`Error updating product: ${error}`);
      if (error instanceof Error) {
        throw new Error(`Failed to update product: ${error.message}`);
      }
      throw error;
    }
  }

  async deleteProduct(data: { user: string; id: string }): Promise<Product> {
    try {
      const product = await prisma.product.delete({
        where: { id: data.id },
      });
      await prisma.productIngredient.deleteMany({
        where: { productId: data.id },
      });

      await auditLog(
        'DELETE_PRODUCT',
        {
          productId: product.id,
          productName: product.name,
          action: 'Deleted product',
        },
        data.user
      );

      return product;
    } catch (error) {
      logger.error(`Error deleting product: ${error}`);
      throw error;
    }
  }

  async getProducts(): Promise<Product[]> {
    try {
      return await prisma.product.findMany({
        include: {
          ingredients: {
            include: {
              ingredient: true,
            },
          },
          category: true,
        },
      });
    } catch (error) {
      logger.error(`Error getting products: ${error}`);
      throw error;
    }
  }

  async getProduct(id: string): Promise<Product> {
    try {
      return await prisma.product.findUnique({
        where: { id },
        include: {
          ingredients: {
            include: {
              ingredient: true,
            },
          },
          category: true,
        },
      });
    } catch (error) {
      logger.error(`Error getting product: ${error}`);
      throw error;
    }
  }

  async createCategory(data: {
    user: string;
    name: string;
    description?: string | null;
  }): Promise<Product> {
    try {
      const category = await prisma.category.create({
        data: {
          name: data.name,
          description: data.description,
        },
      });

      await auditLog(
        'CREATE_CATEGORY',
        {
          categoryId: category.id,
          categoryName: category.name,
          action: 'Created new category',
        },
        data.user
      );

      return category;
    } catch (error) {
      logger.error(`Error creating category: ${error}`);
      throw error;
    }
  }

  async deleteCategory(data: { user: string; id: string }): Promise<Product> {
    try {
      const category = await prisma.category.delete({
        where: { id: data.id },
      });

      await auditLog(
        'DELETE_CATEGORY',
        {
          categoryId: category.id,
          categoryName: category.name,
          action: 'Deleted category',
        },
        data.user
      );

      return category;
    } catch (error) {
      logger.error(`Error deleting category: ${error}`);
      throw error;
    }
  }

  async updateCategory(data: {
    user: string;
    id: string;
    name?: string;
    description?: string | null;
  }): Promise<Category> {
    try {
      const category = await prisma.category.update({
        where: { id: data.id },
        data: {
          name: data.name,
          description: data.description,
        },
      });

      await auditLog(
        'UPDATE_CATEGORY',
        {
          categoryId: category.id,
          categoryName: category.name,
          action: 'Updated category',
        },
        data.user
      );

      return category;
    } catch (error) {
      logger.error(`Error updating category: ${error}`);
      throw error;
    }
  }

  async getCategory(id: string): Promise<Category> {
    try {
      return await prisma.category.findUnique({
        where: { id },
        include: {
          products: true,
        },
      });
    } catch (error) {
      logger.error(`Error getting category: ${error}`);
      throw error;
    }
  }

  async getCategories(): Promise<Product> {
    try {
      return await prisma.category.findMany();
    } catch (error) {
      logger.error(`Error getting categories: ${error}`);
      throw error;
    }
  }

  async updateIngredientStock(data: {
    user: string;
    ingredientId: string;
    quantity: number;
    type: 'PURCHASE' | 'USAGE' | 'ADJUSTMENT' | 'WASTE' | 'RETURN';
    reason?: string;
  }): Promise<IngredientStockLog> {
    try {
      const ingredient = await prisma.ingredient.findUnique({
        where: { id: data.ingredientId },
      });

      if (!ingredient) {
        throw new Error('Ingredient not found');
      }

      // Create stock log
      const stockLog = await prisma.ingredientStockLog.create({
        data: {
          ingredientId: data.ingredientId,
          quantity: data.quantity,
          type: data.type,
          reason: data.reason,
          performedBy: data.user,
        },
      });

      // Update ingredient stock
      await prisma.ingredient.update({
        where: { id: data.ingredientId },
        data: {
          stock: {
            increment: data.quantity,
          },
        },
      });

      return stockLog;
    } catch (error) {
      logger.error('Error updating ingredient stock:', error);
      throw error;
    }
  }

  async getLowStockIngredients(): Promise<Ingredient[]> {
    try {
      return await prisma.ingredient.findMany({
        where: {
          stock: {
            lte: prisma.ingredient.fields.reorderPoint,
          },
        },
        include: {
          supplier: true,
        },
      });
    } catch (error) {
      logger.error('Error getting low stock ingredients:', error);
      throw error;
    }
  }

  async checkProductAvailability(productId: string): Promise<{
    isAvailable: boolean;
    missingIngredients: string[];
  }> {
    try {
      const product = await prisma.product.findUnique({
        where: { id: productId },
        include: {
          ingredients: {
            include: {
              ingredient: true,
            },
          },
        },
      });

      if (!product) {
        throw new Error('Product not found');
      }

      const missingIngredients = product.ingredients
        .filter((pi) => pi.ingredient.stock < pi.quantity)
        .map((pi) => pi.ingredient.name);

      return {
        isAvailable: missingIngredients.length === 0 && product.isAvailable,
        missingIngredients,
      };
    } catch (error) {
      logger.error('Error checking product availability:', error);
      throw error;
    }
  }
}

=== End of /home/rvph/restaurant-manager/backend/src/services/inventory.service.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/middleware/error.handler.ts ===

import { Request, Response, NextFunction } from 'express';
import { logger } from '../lib/logging/logger';

export class AppError extends Error {
  constructor(
    public statusCode: number,
    public message: string,
    public isOperational = true
  ) {
    super(message);
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

export const errorHandler = (
  err: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (err instanceof AppError) {
    logger.warn(`Operational error: ${err.message}`, {
      statusCode: err.statusCode,
      path: req.path,
    });
    return res.status(err.statusCode).json({
      status: 'error',
      message: err.message,
    });
  }

  // Unexpected errors
  logger.error('Unexpected error:', err);
  return res.status(500).json({
    status: 'error',
    message: 'Internal server error',
  });
};

=== End of /home/rvph/restaurant-manager/backend/src/middleware/error.handler.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/middleware/request.logger.ts ===

import { Request, Response, NextFunction } from 'express';
import { logger } from '../lib/logging/logger';

export const requestLogger = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    logger.info(`${req.method} ${req.path}`, {
      duration: `${duration}ms`,
      status: res.statusCode,
      ip: req.ip,
    });
  });

  next();
};

=== End of /home/rvph/restaurant-manager/backend/src/middleware/request.logger.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/middleware/notFound.handler.ts ===

import { Request, Response } from 'express';

export const notFoundHandler = (req: Request, res: Response) => {
  res.status(404).json({
    status: 'error',
    message: `Cannot ${req.method} ${req.path}`,
  });
};

=== End of /home/rvph/restaurant-manager/backend/src/middleware/notFound.handler.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/index.ts ===

import { config } from 'dotenv';
import { createApp } from './app';
import { prisma } from './prisma/client';
import { logger } from './lib/logging/logger';
import http from 'http';

// Load environment variables
config();

const port = process.env.PORT || 5000;

const cleanup = async () => {
  try {
    await prisma.$disconnect();
    logger.info('Cleaned up database and Redis connections');
  } catch (error) {
    logger.error('Error during cleanup:', error);
  }
};

const handleShutdown = async (server: any) => {
  logger.info('Shutdown signal received');

  server.close(async () => {
    logger.info('HTTP server closed');
    await cleanup();
    process.exit(0);
  });

  setTimeout(() => {
    logger.error('Forced shutdown after 30s timeout');
    process.exit(1);
  }, 30000);
};

async function bootstrap() {
  try {
    // Test database connection
    await prisma.$connect();
    logger.info('Successfully connected to database');

    const app = createApp();
    const server = http.createServer(app);

    app.listen(port, () => {
      logger.info(`Server is running on port ${port}`);
      logger.info(`Environment: ${process.env.NODE_ENV}`);
    });

    process.on('SIGTERM', () => handleShutdown(server));
    process.on('SIGINT', () => handleShutdown(server));
  } catch (error) {
    logger.error('Unable to start server:', error);
    await prisma.$disconnect();
    process.exit(1);
  }
}

bootstrap().catch((error) => {
  logger.error('Unhandled error:', error);
  process.exit(1);
});

=== End of /home/rvph/restaurant-manager/backend/src/index.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/prisma/client.ts ===

import { PrismaClient } from '@prisma/client';

declare global {
  // This prevents multiple instances of Prisma Client in development
  var prisma: PrismaClient | undefined;
}

export const prisma =
  global.prisma ||
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  global.prisma = prisma;
}

=== End of /home/rvph/restaurant-manager/backend/src/prisma/client.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/app.ts ===

import express, { Express, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import { router } from './routes/index.routes';
import compression from 'compression';
import { errorHandler, AppError } from './middleware/error.handler';
import { notFoundHandler } from './middleware/notFound.handler';
import { requestLogger } from './middleware/request.logger';

export const createApp = (): Express => {
  const app = express();

  // Global Middlewares
  app.use(
    cors({
      origin: process.env.CORS_ORIGIN,
      credentials: true,
    })
  );
  app.use(helmet());
  app.use(compression());
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  app.use(requestLogger);

  // Health Check
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });

  // API Routes
  app.use('/api', router);

  // Error Handling
  app.use(notFoundHandler);
  app.use((err: Error | AppError, req: Request, res: Response, next: NextFunction) => {
    errorHandler(err, req, res, next);
  });

  return app;
};

=== End of /home/rvph/restaurant-manager/backend/src/app.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/controllers/inventory.controller.ts ===

import { Request, Response } from 'express';
import { InventoryService } from '../services/inventory.service';
import { CustomerService } from '../services/customer.service';
import { AppError } from '../middleware/error.handler';
import { MeasurementUnit } from '@prisma/client';

export class InventoryController {
  private inventoryService: InventoryService;
  private customerService: CustomerService;

  constructor() {
    this.inventoryService = new InventoryService();
    this.customerService = new CustomerService();
  }

  // Ingredient Controllers
  createIngredient = async (req: Request, res: Response) => {
    try {
      const {
        name,
        description,
        stock,
        unit,
        reorderPoint,
        reorderAmount,
        cost,
        extraPrice,
        supplierId,
        userId,
      } = req.body;

      // Basic validation
      if (!name || !unit || !supplierId || !userId) {
        throw new AppError(400, 'Missing required fields');
      }

      // Validate unit is a valid MeasurementUnit
      if (!Object.values(MeasurementUnit).includes(unit)) {
        throw new AppError(400, 'Invalid measurement unit');
      }

      // Validate numeric values
      if (stock < 0 || reorderPoint < 0 || reorderAmount < 0 || cost < 0) {
        throw new AppError(400, 'Numeric values cannot be negative');
      }

      // Check if User exists
      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      const ingredient = await this.inventoryService.createIngredient({
        user: userId,
        name,
        description,
        stock: Number(stock),
        unit: unit as MeasurementUnit,
        reorderPoint: Number(reorderPoint),
        reorderAmount: Number(reorderAmount),
        cost: Number(cost),
        isExtra: extraPrice ? true : false,
        extraPrice: extraPrice ? Number(extraPrice) : null,
        supplierId,
      });

      res.status(201).json({
        status: 'success',
        data: ingredient,
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      throw new AppError(400, 'Failed to create ingredient');
    }
  };

  updateIngredient = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { userId, ...updateData } = req.body;

      if (!userId) {
        throw new AppError(400, 'User ID is required');
      }

      // Check if User exists
      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      const ingredient = await this.inventoryService.updateIngredient({
        user: userId,
        id,
        ...updateData
      });

      res.status(200).json({
        status: 'success',
        data: ingredient,
      });
    } catch (error) {
      if (error instanceof AppError) {
        throw error;
      }
      throw new AppError(400, 'Failed to update ingredient');
    }
  };

  deleteIngredient = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { userId } = req.body;

      if (!userId) {
        throw new AppError(400, 'User ID is required');
      }

      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      await this.inventoryService.deleteIngredient({
        user: userId,
        id
      });

      res.status(204).send();
    } catch (error) {
      throw new AppError(400, 'Failed to delete ingredient');
    }
  };

  getIngredients = async (req: Request, res: Response) => {
    try {
      const ingredients = await this.inventoryService.getIngredients();
      res.status(200).json({
        status: 'success',
        data: ingredients,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to get ingredients');
    }
  };

  getIngredient = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const ingredient = await this.inventoryService.getIngredient(id);
      
      if (!ingredient) {
        throw new AppError(404, 'Ingredient not found');
      }

      res.status(200).json({
        status: 'success',
        data: ingredient,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to get ingredient');
    }
  };

  // Product Controllers
  createProduct = async (req: Request, res: Response) => {
    try {
      const {
        name,
        description,
        categoryId,
        image,
        preparationTime,
        allergens,
        nutritionalInfo,
        price,
        ingredients,
        userId,
      } = req.body;

      if (!name || !categoryId || !price || !ingredients || !userId) {
        throw new AppError(400, 'Missing required fields');
      }

      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      const product = await this.inventoryService.createProduct({
        user: userId,
        name,
        description,
        categoryId,
        image,
        preparationTime: Number(preparationTime),
        allergens,
        nutritionalInfo,
        price: Number(price),
        isAvailable: true,
        ingredients,
      });

      res.status(201).json({
        status: 'success',
        data: product,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to create product');
    }
  };

  updateProduct = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { userId, ...updateData } = req.body;

      if (!userId) {
        throw new AppError(400, 'User ID is required');
      }

      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      const product = await this.inventoryService.updateProduct({
        id,
        user: userId,
        ...updateData,
      });

      res.status(200).json({
        status: 'success',
        data: product,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to update product');
    }
  };

  deleteProduct = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const { userId } = req.body;

      if (!userId) {
        throw new AppError(400, 'User ID is required');
      }

      await this.inventoryService.deleteProduct({
        user: userId,
        id
      });

      res.status(204).send();
    } catch (error) {
      throw new AppError(400, 'Failed to delete product');
    }
  };

  getProducts = async (req: Request, res: Response) => {
    try {
      const products = await this.inventoryService.getProducts();
      res.status(200).json({
        status: 'success',
        data: products,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to get products');
    }
  };

  getProduct = async (req: Request, res: Response) => {
    try {
      const { id } = req.params;
      const product = await this.inventoryService.getProduct(id);
      
      if (!product) {
        throw new AppError(404, 'Product not found');
      }

      res.status(200).json({
        status: 'success',
        data: product,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to get product');
    }
  };

  // Category Controllers
  createCategory = async (req: Request, res: Response) => {
    try {
      const { name, description, userId } = req.body;

      if (!name || !userId) {
        throw new AppError(400, 'Missing required fields');
      }

      if (!await this.customerService.findUser({ id: userId })) {
        throw new AppError(404, 'User not found');
      }

      const category = await this.inventoryService.createCategory({
        user: userId,
        name,
        description,
      });

      res.status(201).json({
        status: 'success',
        data: category,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to create category');
    }
  };

  getCategories = async (req: Request, res: Response) => {
    try {
      const categories = await this.inventoryService.getCategories();
      res.status(200).json({
        status: 'success',
        data: categories,
      });
    } catch (error) {
      throw new AppError(400, 'Failed to get categories');
    }
  };
}
=== End of /home/rvph/restaurant-manager/backend/src/controllers/inventory.controller.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/lib/logging/logger.ts ===

import { createLogger, format, transports } from 'winston';
import { v4 as uuid } from 'uuid';
import { prisma } from '../../prisma/client';

const { combine, timestamp, printf, colorize, errors } = format;

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Define log colors
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

// Custom format for log messages
const logFormat = printf(({ level, message, timestamp, correlationId, ...metadata }) => {
  let meta = '';
  if (Object.keys(metadata).length) {
    meta = '\n' + JSON.stringify(metadata, null, 2);
  }
  const correlationStr = correlationId ? ` [${correlationId}]` : '';
  return `${timestamp} [${level}]${correlationStr}: ${message}${meta}`;
});

// Define which logging level to use based on environment
const level = () => {
  const env = process.env.NODE_ENV || 'development';
  return env === 'development' ? 'debug' : 'info';
};

// Create the logger instance
export const logger = createLogger({
  level: level(),
  levels,
  format: combine(
    errors({ stack: true }),
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    colorize({ all: true }),
    logFormat
  ),
  transports: [
    // Console transport
    new transports.Console(),

    // Error log file transport
    new transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    }),

    // Combined log file transport
    new transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880,
      maxFiles: 5,
    }),
  ],
});

// Add colors to Winston
format.colorize().addColors(colors);

// Error logging utility
export const logError = (error: Error, context: Record<string, any>) => {
  const correlationId = uuid();
  logger.error({
    correlationId,
    message: error.message,
    stack: error.stack,
    ...context,
  });
  return correlationId;
};

// Audit logging utility
export const auditLog = async (action: string, details: any, userId?: string) => {
  const correlationId = uuid();
  try {
    const auditDetails = {
      ...details,
      correlationId,
      timestamp: new Date(),
    };

    await prisma.auditLog.create({
      data: {
        action,
        details: auditDetails,
        userId,
        timestamp: new Date(),
      },
    });

    logger.info(`Audit log created: ${action}`, {
      correlationId,
      userId,
      action,
    });

    return correlationId;
  } catch (error) {
    logger.error('Failed to create audit log:', {
      error,
      action,
      details,
      userId,
      correlationId,
    });
    throw error;
  }
};

// Type definitions for the logger
export type LogLevel = keyof typeof levels;

// Helper functions for consistent logging
export const logMessage = {
  info: (message: string, meta?: Record<string, any>) => {
    logger.info(message, meta);
  },
  error: (message: string, error: Error, meta?: Record<string, any>) => {
    return logError(error, { message, ...meta });
  },
  warn: (message: string, meta?: Record<string, any>) => {
    logger.warn(message, meta);
  },
  debug: (message: string, meta?: Record<string, any>) => {
    logger.debug(message, meta);
  },
  http: (message: string, meta?: Record<string, any>) => {
    logger.http(message, meta);
  },
};

=== End of /home/rvph/restaurant-manager/backend/src/lib/logging/logger.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/config/redis.ts ===

import { createClient } from 'redis';
import { logger } from '../lib/logging/logger';

const redisClient = createClient({
  url: process.env.REDIS_URL || 'redis://localhost:6379',
});

redisClient.on('error', (err) => logger.error('Redis Client Error', err));
redisClient.on('connect', () => logger.info('Redis Client Connected'));

export { redisClient };

=== End of /home/rvph/restaurant-manager/backend/src/config/redis.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/config/socket.ts ===

import { Server } from 'socket.io';
import { Server as HttpServer } from 'http';
import { config } from './index';

export const configureSocket = (server: HttpServer) => {
  const io = new Server(server, {
    cors: {
      origin: config.cors.origin,
      credentials: true,
    },
    connectionStateRecovery: {
      maxDisconnectionDuration: 2 * 60 * 1000,
    },
  });

  io.on('connection', (socket) => {
    console.log('Client connected:', socket.id);

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  });

  return io;
};

=== End of /home/rvph/restaurant-manager/backend/src/config/socket.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/config/sentry.ts ===

import * as Sentry from '@sentry/node';
import { nodeProfilingIntegration } from '@sentry/profiling-node';
import { config } from './index';

export const configureSentry = () => {
  if (process.env.SENTRY_DSN) {
    Sentry.init({
      dsn: process.env.SENTRY_DSN,
      environment: config.env,
      integrations: [nodeProfilingIntegration()],
      tracesSampleRate: config.env === 'production' ? 0.1 : 1.0,
      profilesSampleRate: 1.0,
    });
  }
};

=== End of /home/rvph/restaurant-manager/backend/src/config/sentry.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/config/index.ts ===

import dotenv from 'dotenv';

dotenv.config();

export const config = {
  env: process.env.NODE_ENV || 'development',
  port: parseInt(process.env.PORT || '5000', 10),

  database: {
    url: process.env.DATABASE_URL,
  },

  cors: {
    origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
    credentials: true,
  },

  jwt: {
    secret: process.env.JWT_SECRET || 'your-super-secret-key-change-this',
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  },
};

=== End of /home/rvph/restaurant-manager/backend/src/config/index.ts ===


=== File: /home/rvph/restaurant-manager/backend/src/config/session.ts ===

import session from 'express-session';
import RedisStore from 'connect-redis';
import { redisClient } from './redis';

export const sessionConfig = {
  store: new RedisStore({
    client: redisClient,
    prefix: 'session:',
  }),
  secret: process.env.SESSION_SECRET || 'your-secret-key',
  resave: false,
  saveUninitialized: false,
  name: 'sessionId',
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
  },
};

=== End of /home/rvph/restaurant-manager/backend/src/config/session.ts ===


=== File: /home/rvph/restaurant-manager/docker/backend.Dockerfile ===

FROM node:18.19.0-alpine3.18

# Install PostgreSQL client
RUN apk add --no-cache postgresql-client gnupg

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm install --legacy-peer-deps

# Copy the rest of the application
COPY . .

# Generate Prisma Client
RUN npx prisma generate --schema=./src/prisma/schema.prisma

# Make wait-for-it.sh executable
COPY wait-for-it.sh /wait-for-it.sh
RUN chmod +x /wait-for-it.sh

# Set the entrypoint
ENTRYPOINT ["/wait-for-it.sh"]

EXPOSE 5000

# Default command
CMD ["npm", "run", "dev"]
=== End of /home/rvph/restaurant-manager/docker/backend.Dockerfile ===


=== File: /home/rvph/restaurant-manager/docker/frontend.Dockerfile ===

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install --legacy-peer-deps

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
=== End of /home/rvph/restaurant-manager/docker/frontend.Dockerfile ===


=== File: /home/rvph/restaurant-manager/docker-compose.yml ===

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: ../docker/frontend.Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
      - /app/.next
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:5000
      - NODE_ENV=development
    depends_on:
      - backend
    networks:
      - app-network
    restart: unless-stopped

  backend:
    build:
      context: ./backend
      dockerfile: ../docker/backend.Dockerfile
    ports:
      - "5000:5000"
      - "5555:5555"
    volumes:
      - ./backend:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - PORT=5000
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/restaurant_db
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-super-secret-key-change-this
      - JWT_EXPIRES_IN=7d
      - CORS_ORIGIN=http://localhost:3000
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - app-network
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=restaurant_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - app-network
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
    networks:
      - app-network
    restart: unless-stopped

networks:
  app-network:
    driver: bridge

volumes:
  postgres_data:
  redis_data:
=== End of /home/rvph/restaurant-manager/docker-compose.yml ===


=== File: /home/rvph/restaurant-manager/package.json ===

{
  "name": "restaurant-manager",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "frontend": "cd frontend && npm run dev",
    "backend": "cd backend && npm run dev",
    "dev": "concurrently \"npm run backend\" \"npm run frontend\"",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,md,prisma}\"",
    "format:check": "prettier --check \"**/*.{js,jsx,ts,tsx,json,md,prisma}\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "concurrently": "^9.1.0",
    "prettier": "^3.4.1"
  },
  "devDependencies": {
    "prettier-plugin-prisma": "^5.0.0"
  }
}

=== End of /home/rvph/restaurant-manager/package.json ===


